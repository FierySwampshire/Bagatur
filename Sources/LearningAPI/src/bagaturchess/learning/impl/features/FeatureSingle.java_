

package bagaturchess.learning.impl.features;


import bagaturchess.bitboard.impl.utils.StringUtils;
import bagaturchess.learning.api.IFeature;
import bagaturchess.learning.api.ISignal;
import bagaturchess.learning.impl.signals.Signal;



public class FeatureSingle extends Feature {
	
	/**
	 * 
	 */
	private static final long serialVersionUID = -861041676370138696L;
	
	private Weight openning;
	private Weight endgame;
	
	//private SliderVariableDouble all = new SliderVariableDouble("FeatureSingle");
	
	public FeatureSingle(int _id, String _name, int _complexity,
			double oval, double eval) {
		this(_id, _name, _complexity, oval, oval, oval, eval, eval, eval);
	}
	
	public FeatureSingle(int _id, String _name, int _complexity,
			double _omin, double _omax, double oinitial,
			double _emin, double _emax, double einitial) {
		super(_id, _name, _complexity);
		createNewWeights(_omin, _omax, oinitial, _emin, _emax, einitial);
	}
	
	public void clear() {
		openning.clearStat();
		endgame.clearStat();
	}
	
	@Override
	public void applyChanges() {
		throw new UnsupportedOperationException();
	}
	
	
	public void fitBounds(double buffer) {
		
		boolean changed = openning.fitBounds(buffer);
		changed |= endgame.fitBounds(buffer);
		
		if (changed) {
			openning.clearStat();
			endgame.clearStat();
			
			//all = new SliderVariableDouble("FeatureSingle");
		}
		
		if (changed) {
			//System.out.println("CHANGED: " + this);
		}
	}
	
	public void sign(ISignal signal, double openningPart) {
		double multiplier = openningPart * Math.signum(openning.getWeight());
		multiplier += (1 - openningPart) * Math.signum(endgame.getWeight());
		multiplier = multiplier / 2;
		
		throw new IllegalStateException("implement signal.setStrength");
		//signal.setStrength(signal.getStrength() * multiplier);
	}
	
	public void scale(ISignal signal, double openningPart) {
		double scaled = eval(signal, openningPart);
		//if (scaled != 0) {
			throw new IllegalStateException("implement signal.setStrength");
			//signal.setStrength(scaled);
		//}
	}
	
	public void multiplyAvarageAndCopyToCurrent(IFeature features) {
		openning.multiplyAvarageAndCopyToCurrent(((FeatureSingle)features).openning);
		endgame.multiplyAvarageAndCopyToCurrent(((FeatureSingle)features).endgame);
	}
	
	public void setTo021() {
		openning.set(0, 2, 1);
		endgame.set(0, 2, 1);
	}
	
	public void setAverageToCurrent() {
		openning.setAverageToCurrent();
		endgame.setAverageToCurrent();
	}
	
	public void createNewWeights(double omin, double omax, double oinitial,
			double emin, double emax, double einitial) {	
		openning = new Weight(omin, omax, oinitial);
		endgame = new Weight(emin, emax, einitial);
	}
	
	public void adjust(ISignal signal, double amount, double openningPart) {
		
		//if (Math.abs(amount) != 0) {
		//	all.update(Math.abs(amount));
		//}
		
		//if (!USE_EXC_EXCLUDE || Math.abs(amount) <= all.getPointer()) {
			double adjustment = amount * (signal.getStrength() / signal.getRange());
			
			//adjustment *= signal.getNonNullRate();
			
			if (signal.getStrength() != 0) {
				adjust(adjustment, openningPart);
			}
		//}
	}
	
	private void adjust(double amount, double openingPart) {
		
		//if (amount == 0) throw new IllegalStateException("amount=" + amount);
		
		if (openingPart > 1) {
			openingPart = 1;
		}
				
		if (openingPart > 1 || openingPart < 0) {
			throw new IllegalStateException("openingPart=" + openingPart);
		}
		
		if (openingPart != 0) {
			openning.adjust(openingPart * amount);
		}
		if (1 - openingPart != 0) {
			endgame.adjust((1 - openingPart) * amount);
		}
	}
	
	public double eval(ISignal signal, double openningPart) {
		return getWeight(openningPart) * signal.getStrength();
	}
	
	public double eval1Unit(double openningPart) {
		return getWeight(openningPart) * 1;
	}
	
	private double getWeight(double openningPart) {
		return openningPart * openning.getWeight() + (1 - openningPart) * endgame.getWeight();
		//return openningPart * openning.getAverage() + (1 - openningPart) * endgame.getAverage();
	}
	
	public double getAverage(double openningPart) {
		return openningPart * openning.getAverage() + (1 - openningPart) * endgame.getAverage();
	}
	
	public double getAverage(double openningPart, int subid) {
		throw new UnsupportedOperationException();
	}
	
	@Override
	public String toString() {
		String result = "";
		result += "FEATURE " + StringUtils.fill("" + getId(), 3) + " " +
			StringUtils.fill(getName(), 20) + openning + "    " + endgame;
			//+ "    signal_bounds: " + getSignalMin() + " " + getSignalMax();
		
		return result;
	}

	public ISignal createNewSignal() {
		return new Signal();
	}
}
